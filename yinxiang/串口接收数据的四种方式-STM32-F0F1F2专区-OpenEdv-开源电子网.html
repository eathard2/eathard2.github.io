<html>
<head>
  <title>串口接收数据的四种方式-STM32-F0/F1/F2专区-OpenEdv-开源电子网</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/304720 (zh-CN, DDL); Windows/6.1.7601 Service Pack 1 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="801"/>
<h1>串口接收数据的四种方式-STM32-F0/F1/F2专区-OpenEdv-开源电子网</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2017/4/17 11:00</i></td></tr>
<tr><td><b>来源：</b></td><td><a href="http://www.openedv.com/thread-67915-1-1.html"><i>http://www.openedv.com/thread-67915-1-1.html</i></a></td></tr>
</table>
</div>
<br/>

<div><span><div style="-evernote-webclip:true"><br/><div style="font-size: 16px; display: inline-block;"><div style="word-wrap:break-word;outline:none;"><div style="font-stretch:normal;word-wrap:break-word;outline:none;font-style:normal;font-variant:normal;font-weight:normal;background:rgb(255, 255, 255);font-size:14px;line-height:1.5;font-family:Tahoma, &quot;Microsoft Yahei&quot;, Simsun;color:rgb(0, 0, 0);"><div style="outline:none;word-wrap:break-word;word-break:break-all;min-width:960px;"><div style="outline:none;word-wrap:break-word;word-break:break-all;zoom:1;"><div style="outline:none;word-wrap:break-word;word-break:break-all;background:rgb(239, 239, 239);"><div style="outline:none;word-wrap:break-word;word-break:break-all;"><table style="font-size:inherit;font-weight:inherit;font-style:inherit;font-variant:inherit;word-wrap:break-word;outline:none;empty-cells:show;"><tbody style="word-wrap:break-word;outline:none;"><tr style="word-wrap:break-word;outline:none;"><td style="outline:none;word-wrap:break-word;word-break:break-all;vertical-align:top;background:rgb(232, 232, 232);"><div style="outline:none;word-wrap:break-word;word-break:break-all;"><div style="outline:none;word-wrap:break-word;word-break:break-all;"><div style="outline:none;word-wrap:break-word;word-break:break-all;">


<div style="outline:none;word-wrap:break-word;word-break:break-all;zoom:1;">
<div style="float:left;outline:none;word-wrap:break-word;word-break:break-all;width:90px;height:118px;background:url(&quot;http://openedv.com/static/image/common/rwd.gif&quot;) 0px 0px no-repeat;text-align:center;color:rgb(119, 119, 119);background-position:0px -118px;">
<cite style="word-wrap:break-word;outline:none;font-style:normal;display:block;margin:26px auto 6px;height:30px;font-size:28px;">1</cite>金钱</div>
<div style="outline:none;word-wrap:break-word;word-break:break-all;margin-left:110px;">
<table cellpadding="0" cellspacing="0" style="font-size:inherit;font-weight:inherit;font-style:inherit;font-variant:inherit;word-wrap:break-word;outline:none;empty-cells:show;border-collapse:collapse;table-layout:fixed;width:100%;"><tbody style="word-wrap:break-word;outline:none;"><tr style="word-wrap:break-word;outline:none;"><td style="outline:none;word-wrap:break-word;word-break:break-all;font-size:15px;"><table cellspacing="0" style="empty-cells:show;font-size:inherit;font-style:inherit;font-variant:inherit;word-wrap:break-word;font-weight:inherit;width:98%;outline:none;border-collapse:collapse;border:1px solid rgb(227, 237, 245);table-layout:auto;"><tbody style="word-wrap:break-word;outline:none;"><tr style="word-wrap:break-word;outline:none;"><td style="outline:none;word-wrap:break-word;word-break:break-all;font-size:15px;padding:4px;border:1px solid rgb(227, 237, 245);overflow:hidden;"><div align="center" style="outline:none;word-wrap:break-word;word-break:break-all;"><font style="word-wrap:break-word;outline:none;color:rgb(153, 153, 153);"><font style="word-wrap:break-word;outline:none;font-size:12px;"><br style="word-wrap:break-word;outline:none;"/><strong style="word-wrap:break-word;outline:none;font-weight:700;"><font color="#FF0000" style="word-wrap:break-word;outline:none;"></font></strong>
</font></font></div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">首先需要配置<font face="Times New Roman" style="word-wrap:break-word;outline:none;">stm32</font><font face="宋体" style="word-wrap:break-word;outline:none;">的串口：</font></div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">1、使能时钟</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">2、使能串口中断</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">3、初始化串口</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">这里想重点说明一下串口数据的接收策略：</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">不怕麻烦举四个例子说明，如果很了解就跳过，初学者还是有作用的（欢迎拍砖）</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">实例一：</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">void USART1_IRQHandler(u8 GetData)</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">{</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">u8 BackData;</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET) //中断产生</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">{  </div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">USART_ClearITPendingBit(USART1,USART_IT_RXNE);   //清除中断标志.</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">            GetData = UART1_GetByte(BackData);   //也行GetData=USART1-&gt;DR;   </div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">USART1_SendByte(GetData);         //发送数据</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">GPIO_SetBits(GPIOE, GPIO_Pin_8 ); //LED闪烁，接收成功发送完成</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">delay(1000);</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">GPIO_ResetBits(GPIOE, GPIO_Pin_8 );</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">}</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">}  </div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">这是最基本的，将数据接收完成后又发送出去，接收和发送在中断函数里执行，<font face="Times New Roman" style="word-wrap:break-word;outline:none;">main</font><font face="宋体" style="word-wrap:break-word;outline:none;">函数里无其他要处理的。</font></div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">优点：简单，适合很少量数据传输。</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">缺点：无缓存区，并且对数据的正确性没有判断，数据量稍大可能导致数据丢失 。</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">实例二：</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">void USART2_IRQHandler()  </div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">{</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">if(USART_GetITStatus(USART2,USART_IT_RXNE) != RESET) //中断产生</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">{  </div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">USART_ClearITPendingBit(USART2,USART_IT_RXNE);       //清除中断标志</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">Uart2_Buffer[Uart2_Rx_Num] = USART_ReceiveData(USART2);</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">Uart2_Rx_Num++;</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">}</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">if((Uart2_Buffer[0] == 0x5A)&amp;&amp;(Uart2_Buffer[Uart2_Rx_Num-1] == 0xA5))  //判断最后接收的数据是否为设定值，确定数据正确性</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">Uart2_Sta=1;</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">if(USART_GetFlagStatus(USART2,USART_FLAG_ORE) == SET) //溢出</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">{</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">USART_ClearFlag(USART2,USART_FLAG_ORE);  //读SR</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">USART_ReceiveData(USART2); //读DR  </div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">}     </div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">}</div><br style="word-wrap:break-word;outline:none;"/>
<div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">if( Uart2_Sta )</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">{</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">for(Uart2_Tx_Num=0;Uart2_Tx_Num &lt; Uart2_Rx_Num;Uart2_Tx_Num++)</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">USART2_SendByte(Uart2_Buffer[Uart2_Tx_Num]); //发送数据</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">Uart2_Rx_Num = 0; //初始化</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">Uart2_Tx_Num = 0;</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">Uart2_Sta = 0;</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">}</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">这是加了数据头和数据尾的接收方式，数据头和尾的个数可增加，此处只用于调试之用。中断函数用于接收数据以及判断数据的头尾，第二个函数在<font face="Times New Roman" style="word-wrap:break-word;outline:none;">main</font><font face="宋体" style="word-wrap:break-word;outline:none;">函数里按照查询方式执行。</font></div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">优点：较简单，采用缓存区接收，对提高数据的正确行有一定的改善 。</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">缺点：要是第一次数据接收错误，回不到初始化状态，必须复位操作 。</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">实例三：</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">void USART2_IRQHandler()</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">{</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">     if(USART_GetITStatus(USART2,USART_IT_RXNE) != RESET) //中断产生</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">     {</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">        USART_ClearITPendingBit(USART2,USART_IT_RXNE); //清除中断标志.</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">        Uart2_Buffer[Uart2_Rx] = USART_ReceiveData(USART2);</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">        Uart2_Rx++;</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">        Uart2_Rx &amp;= 0x3F; //判断是否计数到最大</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">      }</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">      if(USART_GetFlagStatus(USART2,USART_FLAG_ORE) == SET) //溢出</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">      {</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">          USART_ClearFlag(USART2,USART_FLAG_ORE); //读SR</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">          USART_ReceiveData(USART2); //读DR</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">       }</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">}</div><br style="word-wrap:break-word;outline:none;"/>
<div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">if( Uart2_Tx != Uart2_Rx )</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">{</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">    USART2_SendByte(Uart2_Buffer[Uart2_Tx]); //发送数据</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">    Uart2_Tx++;</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">    Uart2_Tx &amp;= 0x3F; //判断是否计数到最大</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">}  </div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">采用<font face="Times New Roman" style="word-wrap:break-word;outline:none;">FIFO</font><font face="宋体" style="word-wrap:break-word;outline:none;">方式接收数据，由</font><font face="Times New Roman" style="word-wrap:break-word;outline:none;">0x3F</font><font face="宋体" style="word-wrap:break-word;outline:none;">可知此处最大接收量为</font><font face="Times New Roman" style="word-wrap:break-word;outline:none;">64</font><font face="宋体" style="word-wrap:break-word;outline:none;">个，可变，中断函数只负责收，另一函数在</font><font face="Times New Roman" style="word-wrap:break-word;outline:none;">main</font><font face="宋体" style="word-wrap:break-word;outline:none;">函数里执行，</font><font face="Times New Roman" style="word-wrap:break-word;outline:none;">FIFO</font><font face="宋体" style="word-wrap:break-word;outline:none;">方式发送。</font></div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">优点：发送和接收都很自由，中断占用时间少，有利于<font face="Times New Roman" style="word-wrap:break-word;outline:none;">MCU</font><font face="宋体" style="word-wrap:break-word;outline:none;">处理其它。</font></div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">缺点：对数据的正确性没有判断，一概全部接收。</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">实例四：</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">void USART2_IRQHandler()</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">{</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">     if(USART_GetITStatus(USART2,USART_IT_RXNE) != RESET) //中断产生</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">     {</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">        USART_ClearITPendingBit(USART2,USART_IT_RXNE); //清除中断标志</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">        Uart2_Buffer[Uart2_Rx] = USART_ReceiveData(USART2);</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">        Uart2_Rx++;</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">        Uart2_Rx &amp;= 0xFF;</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">     }</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">     if(Uart2_Buffer[Uart2_Rx-1] == 0x5A) //头</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">        Uart2_Tx = Uart2_Rx-1;</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">     if((Uart2_Buffer[Uart2_Tx] == 0x5A)&amp;&amp;(Uart2_Buffer[Uart2_Rx-1] == 0xA5)) //   检测到头的情况下检测到尾</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">     {</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">            Uart2_Len = Uart2_Rx-1- Uart2_Tx; //长度</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">            Uart2_Sta=1; //标志位</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">     }</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">     if(USART_GetFlagStatus(USART2,USART_FLAG_ORE) == SET) //溢出</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">     {</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">            USART_ClearFlag(USART2,USART_FLAG_ORE); //读SR</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">            USART_ReceiveData(USART2); //读DR</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">     }</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">}</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">if( Uart2_Sta )</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">{</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">        for(tx2=0;tx2 &lt;= Uart2_Len;tx2++,Uart2_Tx++)</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">                USART2_SendByte(Uart2_Buffer[Uart2_Tx]); //发送数据</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">        Uart2_Rx = 0; //初始化</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">        Uart2_Tx = 0;</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">        Uart2_Sta = 0;</div><div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">}</div><br style="word-wrap:break-word;outline:none;"/>
<br style="word-wrap:break-word;outline:none;"/>
<br style="word-wrap:break-word;outline:none;"/>
<br style="word-wrap:break-word;outline:none;"/>
<br style="word-wrap:break-word;outline:none;"/>
<div align="left" style="outline:none;word-wrap:break-word;word-break:break-all;">对于第三种FIFO方式不是很理解，望大家赐教</div></td></tr></tbody></table><br style="word-wrap:break-word;outline:none;"/>
</td></tr></tbody></table>
</div>
<span style="display:block;height:0px;clear:both;visibility:hidden;">.</span></div>

<div style="outline:none;word-wrap:break-word;word-break:break-all;">
<h3 style="word-wrap:break-word;outline:none;margin:2em 0px 2em -20px;padding:5px 45px 5px 20px;font-size:14px;width:240px;background:url(&quot;http://openedv.com/static/image/common/arw.gif&quot;) 100% 50% no-repeat rgb(255, 244, 221);color:rgb(242, 108, 79);">最佳答案</h3>
<div style="outline:none;word-wrap:break-word;word-break:break-all;clear:left;padding:0.5em 0px;">
<div style="outline:none;word-wrap:break-word;word-break:break-all;vertical-align:middle;float:left;width:140px;line-height:24px;overflow:hidden;"><a href="http://www.openedv.com/home.php?mod=space&amp;uid=" style="word-wrap:break-word;color:rgb(0, 0, 0);text-decoration:none;outline:none;vertical-align:middle;"><img src="串口接收数据的四种方式-STM32-F0F1F2专区-OpenEdv-开源电子网_files/Image.png" type="image/png" height="24" style="word-wrap:break-word;outline:none;border:none;vertical-align:middle;width:24px;height:24px;" width="24"/></a> <a href="http://www.openedv.com/space-uid-44827.html" style="word-wrap:break-word;text-decoration:none;outline:none;color:rgb(0, 102, 153);font-weight:700;vertical-align:middle;">钩月黄昏</a></div>
<div style="outline:none;word-wrap:break-word;word-break:break-all;margin-left:140px;line-height:24px;">
<p style="word-wrap:break-word;outline:none;margin:0px;padding:0px;color:rgb(0, 102, 153);"><a href="#" style="word-wrap:break-word;text-decoration:none;outline:none;color:rgb(0, 102, 153);">查看完整内容<span style="word-wrap:break-word;outline:none;color:red;">[请看2#楼]</span></a></p>
<div style="outline:none;word-wrap:break-word;word-break:break-all;margin-top:5px;">1.通过串口接收中断一个字节一个字节接收数据，同时用定时器来计算接收到数据的时间间隔，如果超过一定时间没有接收到数据则判断为一帧数据接受完，然后再对数据进行解析
2，通过DMA接收，加串口空闲中断方式，只在接收完一帧数据后才会产生中断，然后对数据进行解析
用这两种方法不是更好么？？</div>
</div>
</div>
</div>





<br style="word-wrap:break-word;outline:none;"/>



</div></div></div></td></tr></tbody></table></div></div></div></div></div></div></div><br/></div></span>
</div></body></html> 