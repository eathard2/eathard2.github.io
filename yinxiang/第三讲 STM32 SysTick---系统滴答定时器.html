<html>
<head>
  <title>第三讲 STM32 SysTick---系统滴答定时器</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/304720 (zh-CN, DDL); Windows/6.1.7601 Service Pack 1 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="665"/>
<h1>第三讲 STM32 SysTick---系统滴答定时器</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2017/4/11 21:57</i></td></tr>
<tr><td><b>来源：</b></td><td><a href="http://www.51hei.com/stm32/3873.html"><i>http://www.51hei.com/stm32/3873.html</i></a></td></tr>
</table>
</div>
<br/>

<div><span><div style="-evernote-webclip:true"><br/><div><div><div><div><h1>第三讲 STM32 SysTick---系统滴答定时器</h1><div><div></div></div></div>
	
	
	  <div> 作者:鹏心飞漾   来源:转自鹏心飞漾   点击数:  更新时间：2014年07月28日   【字体：<a href="#" target="_blank">大</a> <a href="#" target="_blank">中</a> <a href="#" target="_blank">小</a>】 </div>
	  
	  
	  
	  
	  
	  
	 <p>一、Systick简介</p>
<div>    Systick也叫系统滴答定时器，滴答定时器就是一个非常基本的倒计时定时器。它存在的意义是为系统提供一个时基，能够给操作系统提供一个硬件上的中断。使用Systick能够精准延时，对于时间要求严格的场所，意义十分重大，我将写一个流水灯改进版----精确延时(可调控)的流水灯。</div>
<div>二、Systick timer</div>
<div>    Systick是一个24位的定时器，一次最多可以计数2^24个时钟脉冲，这个脉冲计数值保存在当前计数值寄存器STK_VAL（Systick current value register）中,只能向下计数，每接收到一个时钟脉冲，STK_VAL的值就会向下减1，当减到0时，硬件会自动把重装载寄存器STK_LOAD（Systick reload value register）中保存的数据加载到STK_VAL，重新开始向下计数。如果STK_VAL的值被减至0时，会触发异常产生中断。</div>
<div>三、相关寄存器介绍</div>
<div>除了上面说的STK_VAL，下面带大家了解相关的寄存器和寄存器位。</div>
<div>1.  SysTick_CSR       控制状态寄存器</div>

<div><a href="http://www.51hei.com/UpFiles/up/0/472716434113603.jpg" target="_blank"><div><img src="第三讲 STM32 SysTick---系统滴答定时器_files/Image.jpg" type="image/jpeg" height="217" width="576"/></div></a><br/>
<a href="http://www.51hei.com/UpFiles/up/0/472716454145263.jpg" target="_blank"><div><img src="第三讲 STM32 SysTick---系统滴答定时器_files/Image [1].jpg" type="image/jpeg" height="282" width="576"/></div></a><br/>
Bit0： ENABLE</div>
<div>          SysTick timer的使能位，1使能Systick timer，0关闭Systick timer</div>
<div>Bit1： TICKINT</div>
<div>          异常触发使能位，TICKINT=1，STK_VAL计数到0触发异常；TICKINT=0，不触发异常</div>
<div>Bit2： CLKSOURCE</div>
<div>          Systick时钟选择位，SysTick = 1，时钟为AHB时钟；0时钟位AHB/8</div>
<div>Bit16：COUNTFLAG</div>
<div>          计数为0标志位， 当STK_VAL计数到0，此标志位会被置1       </div>

<div>
2. SysTick_LOAD      重装载寄存器</div>

<div><a href="http://www.51hei.com/UpFiles/up/0/47271646415130.jpg" target="_blank"><div><img src="第三讲 STM32 SysTick---系统滴答定时器_files/Image [2].jpg" type="image/jpeg" height="147" width="576"/></div></a></div>
<div>0-23 24位的重装值，这也是为什么只能计数到2^24</div>
<div>3.  SysTick_VAL    当前值寄存器</div>
<div>
<a href="http://www.51hei.com/UpFiles/up/0/472716464169747.jpg" target="_blank"><div><img src="第三讲 STM32 SysTick---系统滴答定时器_files/Image [3].jpg" type="image/jpeg" height="192" width="576"/></div></a></div>

<div>4.  SysTick_CALRB    校准寄存器</div>
<div><a href="http://www.51hei.com/UpFiles/up/0/472716464145151.jpg" target="_blank"><div><img src="第三讲 STM32 SysTick---系统滴答定时器_files/Image [4].jpg" type="image/jpeg" height="285" width="576"/></div></a></div>
<div>由于我们要写精确延时的LED流水灯，所以我们需要使用Systick进行精确延时，理论上它的最小计时单位为AHB的时钟周期，1/72000000秒，72分之一微秒。</div>

<div>我们在昨天流水灯的基础上，新建两个文件，SysTick.c和SysTick.h</div>
<div>具体代码如下</div>
<div>SysTick.h</div>
<div>#ifndef __SYSTICK_H__<br/>
#define __SYSTICK_H__<br/>
#include &quot;stm32f10x.h&quot;</div>
<div>void SysTick_Init(void);</div>
<div>void Delay_us(__IO u32 nTime);</div>
<div>#endif</div>

<div>SysTick.c</div>
<div>#include &quot;SysTick.h&quot;<br/>
#include &quot;stm32f10x.h&quot;</div>
<div>static __IO u32 TimingDelay;</div>
<div>void SysTick_Init(void)<br/>
{<br/>
 if(SysTick_Config(SystemCoreClock/100000))<br/>
 {<br/>
  while(1);<br/>
 }<br/>
 //关闭滴答定时器<br/>
 SysTick-&gt;CTRL &amp;= ~SysTick_CTRL_ENABLE_Msk;<br/>
}</div>
<div>void TimingDelay_Decrement(void)<br/>
{<br/>
 if(TimingDelay != 0x00)<br/>
 {<br/>
  TimingDelay--;<br/>
 }<br/>
}</div>
<div>void Delay_us(__IO u32 nTime)<br/>
{<br/>
 TimingDelay = nTime;<br/><br/>//使能滴答定时器<br/>
 SysTick-&gt;CTRL |= SysTick_CTRL_ENABLE_Msk;<br/><br/>while(TimingDelay != 0);<br/>
}</div>

<div>中断函数，在stm32f10xit.c</div>
<div>void SysTick_Handler(void)<br/>
{<br/>
 TimingDelay_Decrement();<br/>
}</div>

<div>修改main.c如下</div>
<div>#include &quot;stm32f10x.h&quot;<br/>
#include &quot;led.h&quot;<br/>
#include &quot;SysTick.h&quot;</div>
<div>
int main(void)<br/>
{<br/>
 //LED端初始化<br/>
 LED_GPIO_Config();<br/><br/>//配置SysTick为10us中断一次<br/>
 SysTick_Init();<br/><br/>while(1)<br/>
 {<br/>
  LED1(0);<br/>
  Delay_us(50000);<br/>
  LED1(1);<br/><br/>LED2(0);<br/>
  Delay_us(50000);<br/>
  LED2(1);<br/><br/>LED3(0);<br/>
  Delay_us(50000);<br/>
  LED3(1);<br/><br/>LED4(0);<br/>
  Delay_us(50000);<br/>
  LED4(1);<br/>
 }<br/>
}</div>
<div>这里面只有两个函数，SysTick_Init()和Delay_us(),一个是配置SysTick定时器，一个是进行精确延时</div>
<div>中断函数也只是运行了一个自定义函数，看看不难理解</div>
<div>SysTick_Config(SystemCoreClock/100000);</div>
<div>SystemCoreClock是系统时钟的宏，SystemCoreClock = 72000000</div>
<div>我们的计时总时间 T = tick * （1/f），tick为SysTick_Config()的输入参数</div>
<div>1/f为SysTick timer使用的时钟源的时钟周期，f为该时钟源的时钟频率。</div>
<div>上面的语句中：tick = SystemCoreClock/100000=720，表示720个时钟周期中断一次，1/f是时钟周期的时间，1/f = 1/72us,所以T = 720*(1/72) = 10us</div>
<div>SysTick_CTRL_ENABLE_Msk,这是一个宏，用来指示寄存器的特定位置或进行位屏蔽用的，那么他是如何定义的呢？</div>
<div><a href="http://www.51hei.com/UpFiles/up/0/472716474165177.jpg" target="_blank"><div><img src="第三讲 STM32 SysTick---系统滴答定时器_files/Image [5].jpg" type="image/jpeg" height="422" width="576"/></div></a><br/><br/>其中的寄存器位指示宏：SysTick_xxx_Pos, 宏展开后为xxx在相应寄存器中的位置，如控制SysTick时钟源的SysTick_CTRL_CLKSOURCE_Pos，宏展开后为2，正好是SysTick_CSR中的Bit2</div>
<div>寄存器的位屏蔽宏：SysTick_xxx_Msk,宏展开是xxx的位全部置1后，左移SysTick_xxx_Pos位，1ul使之无符号长整型，上图中SysTick_CTRL_CLKSOURCE_Msk,宏展开为1ul&lt;&lt;SysTick_CTRL_CLKSOURCE_Pos,即1左移2位，得到的只有Bit2：CLKSOURCE位被置1，而其它位为0，这样搭配&amp; | 能够很方便的修改寄存器的某些位，这样就程序就不难理解了.就说这么多吧，已经讲得很多了，不懂得自己想想，琢磨一下就通了。</div>

	  
	  
  
  </div></div></div><br/></div></span>
</div></body></html> 