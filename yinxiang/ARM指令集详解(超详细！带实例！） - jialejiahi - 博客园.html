<html>
<head>
  <title>ARM指令集详解(超详细！带实例！） - jialejiahi - 博客园</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/304720 (zh-CN, DDL); Windows/6.1.7601 Service Pack 1 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1038"/>
<h1>ARM指令集详解(超详细！带实例！） - jialejiahi - 博客园</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2017/7/10 15:46</i></td></tr>
<tr><td><b>来源：</b></td><td><a href="https://www.cnblogs.com/liujiahi/archive/2011/03/22/2196401.html"><i>https://www.cnblogs.com/liujiahi/archive/2011/03/22/2196401.html</i></a></td></tr>
</table>
</div>
<br/>

<div><span><div style="-evernote-webclip:true"><br/><div style="font-size: 16px; display: inline-block;"><div><div style="font-family:&quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif;color:rgb(0, 0, 0);background:rgb(255, 255, 255);font-size:14px;"><div style="min-width:930px;"><div style="min-width:950px;text-align:left;"><div style="text-overflow:ellipsis;overflow:hidden;word-break:break-all;"><div><div><div style="text-overflow:ellipsis;overflow:hidden;word-break:break-all;background-color:rgb(245, 250, 254);"><div><div style="line-height:1.5;color:rgb(0, 0, 0);"><div style="word-break:break-word;"><span style="margin:0px;padding:0px;line-height:1.5;font-size:18px;color:#3d85c6;"><h1 align="center" style="padding:0px;font-size:28px;font-weight:bold;line-height:1.5;margin:10px 0px;"><span style="margin:0px;padding:0px;line-height:1.5;color:#202020;">算术和逻辑指令</span></h1>
<h2 style="padding:0px;font-size:21px;font-weight:bold;line-height:1.5;margin:10px 0px;">ADC : 带进位的加法</h2>
<p style="padding:0px;margin:10px auto;text-indent:0px;">(<span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">Ad</span>dition with <span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">C</span>arry)</p>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">ADC{条件}{S}  &lt;dest&gt;, &lt;op 1&gt;, &lt;op 2&gt;

                dest = op_1 + op_2 + carry</pre>
<p style="padding:0px;margin:10px auto;text-indent:0px;"><code style="margin:0px;padding:0px;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:新宋体;">ADC</span></code> 将把两个操作数加起来，并把结果放置到目的寄存器中。它使用一个进位标志位，这样就可以做比 32 位大的加法。下列例子将加两个 128 位的数。<br style="margin:0px;padding:0px;"/>
128 位结果: 寄存器 0、1、2、和 3<br style="margin:0px;padding:0px;"/>
第一个 128 位数: 寄存器 4、5、6、和 7<br style="margin:0px;padding:0px;"/>
第二个 128 位数: 寄存器 8、9、10、和 11。</p>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">ADDS    R0, R4, R8              ; 加低端的字
  ADCS    R1, R5, R9              ; 加下一个字，带进位
  ADCS    R2, R6, R10             ; 加第三个字，带进位
  ADCS    R3, R7, R11             ; 加高端的字，带进位</pre>
<p style="padding:0px;margin:10px auto;text-indent:0px;">如果如果要做这样的加法，不要忘记设置 S 后缀来更改进位标志。</p>
<p style="padding:0px;margin:10px auto;text-indent:0px;">　</p>
<p style="padding:0px;margin:10px auto;text-indent:0px;"><a name="add" style="margin:0px;padding:0px;width:20px;height:20px;text-indent:20px;background-image:url('http://www.cnblogs.com/CuteSoft_Client/CuteEditor/Load.ashx?type=image&amp;file=anchor.gif');background-repeat:no-repeat no-repeat;"></a></p><a name="add" style="margin:0px;padding:0px;">
<h2 style="padding:0px;font-size:21px;font-weight:bold;line-height:1.5;margin:10px 0px;">ADD : 加法</h2>
<p style="padding:0px;margin:10px auto;text-indent:0px;">(<span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">Add</span>ition)</p>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">ADD{条件}{S}  &lt;dest&gt;, &lt;op 1&gt;, &lt;op 2&gt;

                dest = op_1 + op_2</pre>
<p style="padding:0px;margin:10px auto;text-indent:0px;"><code style="margin:0px;padding:0px;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:新宋体;">ADD</span></code> 将把两个操作数加起来，把结果放置到目的寄存器中。操作数 1 是一个寄存器，操作数 2 可以是一个寄存器，被移位的寄存器，或一个立即值:</p>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">ADD     R0, R1, R2              ; R0 = R1 + R2
  ADD     R0, R1, #256            ; R0 = R1 + 256
  ADD     R0, R2, R3,LSL#1        ; R0 = R2 + (R3 &lt;&lt; 1)</pre>
<p style="padding:0px;margin:10px auto;text-indent:0px;">加法可以在有符号和无符号数上进行。</p>
<p style="padding:0px;margin:10px auto;text-indent:0px;">　</p>
<p style="padding:0px;margin:10px auto;text-indent:0px;">
</p><h2 style="padding:0px;font-size:21px;font-weight:bold;line-height:1.5;margin:10px 0px;">AND : 逻辑与</h2>
<p style="padding:0px;margin:10px auto;text-indent:0px;">(logical <span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">AND</span>)</p>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">AND{条件}{S}  &lt;dest&gt;, &lt;op 1&gt;, &lt;op 2&gt;

                dest = op_1 AND op_2</pre>
<p style="padding:0px;margin:10px auto;text-indent:0px;"><code style="margin:0px;padding:0px;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:新宋体;">AND</span></code> 将在两个操作数上进行逻辑与，把结果放置到目的寄存器中；对屏蔽你要在上面工作的位很有用。 操作数 1 是一个寄存器，操作数 2 可以是一个寄存器，被移位的寄存器，或一个立即值:</p>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">AND     R0, R0, #3              ; R0 = 保持 R0 的位 ０ 和 1，丢弃其余的位。</pre>
<p style="padding:0px;margin:10px auto;text-indent:0px;">AND 的真值表(二者都是 1 则结果为 1):</p>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">Op_1   Op_2   结果

  0      0      0
  0      1      0
  1      0      0
  1      1      1
　</pre>
<p style="padding:0px;margin:10px auto;text-indent:0px;">
</p><h2 style="padding:0px;font-size:21px;font-weight:bold;line-height:1.5;margin:10px 0px;">BIC : 位清除</h2>
<p style="padding:0px;margin:10px auto;text-indent:0px;">(<span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">Bi</span>t <span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">C</span>lear)</p>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">BIC{条件}{S}  &lt;dest&gt;, &lt;op 1&gt;, &lt;op 2&gt;

                dest = op_1 AND (!op_2)</pre>
<p style="padding:0px;margin:10px auto;text-indent:0px;"><code style="margin:0px;padding:0px;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:新宋体;">BIC</span></code> 是在一个字中清除位的一种方法，与 OR 位设置是相反的操作。操作数 2 是一个 32 位位掩码(mask)。如果如果在掩码中设置了某一位，则清除这一位。未设置的掩码位指示此位保持不变。</p>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">BIC     R0, R0, #%1011          ; 清除 R0 中的位 0、1、和 3。保持其余的不变。</pre>
<p style="padding:0px;margin:10px auto;text-indent:0px;">BIC 真值表 :</p>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">Op_1   Op_2   结果

  0      0      0
  0      1      0
  1      0      1
  1      1      0</pre>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">译注：逻辑表达式为 Op_1 AND NOT Op_2</pre>
<p style="padding:0px;margin:10px auto;text-indent:0px;">　</p>
<p style="padding:0px;margin:10px auto;text-indent:0px;">
</p><h2 style="padding:0px;font-size:21px;font-weight:bold;line-height:1.5;margin:10px 0px;">EOR : 逻辑异或</h2>
<p style="padding:0px;margin:10px auto;text-indent:0px;">(logical <span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">E</span>xclusive <span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">OR</span>)</p>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">EOR{条件}{S}  &lt;dest&gt;, &lt;op 1&gt;, &lt;op 2&gt;

                dest = op_1 EOR op_2</pre>
<p style="padding:0px;margin:10px auto;text-indent:0px;"><code style="margin:0px;padding:0px;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:新宋体;">EOR</span></code> 将在两个操作数上进行逻辑异或，把结果放置到目的寄存器中；对反转特定的位有用。操作数 1 是一个寄存器，操作数 2 可以是一个寄存器，被移位的寄存器，或一个立即值:</p>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">EOR     R0, R0, #3              ; 反转 R0 中的位 0 和 1</pre>
<p style="padding:0px;margin:10px auto;text-indent:0px;">EOR 真值表(二者不同则结果为 1):</p>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">Op_1   Op_2   结果

  0      0      0
  0      1      1
  1      0      1
  1      1      0
　</pre>
<p style="padding:0px;margin:10px auto;text-indent:0px;">
</p><h2 style="padding:0px;font-size:21px;font-weight:bold;line-height:1.5;margin:10px 0px;">MOV : 传送</h2>
<p style="padding:0px;margin:10px auto;text-indent:0px;">(<span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">Mov</span>e)</p>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">MOV{条件}{S}  &lt;dest&gt;, &lt;op 1&gt;

                dest = op_1</pre>
<p style="padding:0px;margin:10px auto;text-indent:0px;"><code style="margin:0px;padding:0px;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:新宋体;">MOV</span></code> 从另一个寄存器、被移位的寄存器、或一个立即值装载一个值到目的寄存器。你可以指定相同的寄存器来实现 NOP 指令的效果，你还可以专门移位一个寄存器:</p>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">MOV     R0, R0                  ; R0 = R0... NOP 指令

  MOV     R0, R0, LSL#3           ; R0 = R0 * 8</pre>
<p style="padding:0px;margin:10px auto;text-indent:0px;">如果 R15 是目的寄存器，将修改程序计数器或标志。这用于返回到调用代码，方法是把连接寄存器的内容传送到 R15:</p>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">MOV     PC, R14                 ; 退出到调用者

  MOVS    PC, R14                 ; 退出到调用者并恢复标志位
                                    <span style="margin:0px;padding:0px;line-height:1.5;color:#ff0000;">(不遵从 32-bit 体系)</span>
　</pre>
<p style="padding:0px;margin:10px auto;text-indent:0px;">
</p><h2 style="padding:0px;font-size:21px;font-weight:bold;line-height:1.5;margin:10px 0px;">MVN : 传送取反的值</h2>
<p style="padding:0px;margin:10px auto;text-indent:0px;">(<span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">M</span>o<span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">v</span>e<span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">N</span>egative)</p>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">MVN{条件}{S}  &lt;dest&gt;, &lt;op 1&gt;

                dest = !op_1</pre>
<p style="padding:0px;margin:10px auto;text-indent:0px;"><code style="margin:0px;padding:0px;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:新宋体;">MVN</span></code> 从另一个寄存器、被移位的寄存器、或一个立即值装载一个值到目的寄存器。不同之处是在传送之前位被反转了，所以把一个被取反的值传送到一个寄存器中。这是逻辑非操作而不是算术操作，这个取反的值加 1 才是它的取负的值:</p>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">MVN     R0, #4                  ; R0 = -5

  MVN     R0, #0                  ; R0 = -1
　</pre>
<p style="padding:0px;margin:10px auto;text-indent:0px;">
</p><h2 style="padding:0px;font-size:21px;font-weight:bold;line-height:1.5;margin:10px 0px;">ORR : 逻辑或</h2>
<p style="padding:0px;margin:10px auto;text-indent:0px;">(logical <span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">OR</span>)</p>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">ORR{条件}{S}  &lt;dest&gt;, &lt;op 1&gt;, &lt;op 2&gt;

                dest = op_1 OR op_2</pre>
<p style="padding:0px;margin:10px auto;text-indent:0px;"><code style="margin:0px;padding:0px;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:新宋体;">OR</span></code> 将在两个操作数上进行逻辑或，把结果放置到目的寄存器中；对设置特定的位有用。操作数 1 是一个寄存器，操作数 2 可以是一个寄存器，被移位的寄存器，或一个立即值:</p>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">ORR     R0, R0, #3              ; 设置 R0 中位 0 和 1</pre>
<p style="padding:0px;margin:10px auto;text-indent:0px;">OR 真值表(二者中存在 1 则结果为 1):</p>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">Op_1   Op_2   结果

  0      0      0
  0      1      1
  1      0      1
  1      1      1
　</pre>
<p style="padding:0px;margin:10px auto;text-indent:0px;">
</p><h2 style="padding:0px;font-size:21px;font-weight:bold;line-height:1.5;margin:10px 0px;">RSB : 反向减法</h2>
<p style="padding:0px;margin:10px auto;text-indent:0px;">(<span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">R</span>everse <span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">S</span>u<span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">b</span>traction)</p>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">RSB{条件}{S}  &lt;dest&gt;, &lt;op 1&gt;, &lt;op 2&gt;

                dest = op_2 - op_1</pre>
<p style="padding:0px;margin:10px auto;text-indent:0px;"><code style="margin:0px;padding:0px;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:新宋体;">SUB</span></code> 用操作数 <strong style="margin:0px;padding:0px;">two </strong>减去操作数 <strong style="margin:0px;padding:0px;">one</strong>，把结果放置到目的寄存器中。操作数 1 是一个寄存器，操作数 2 可以是一个寄存器，被移位的寄存器，或一个立即值:</p>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">RSB     R0, R1, R2              ; R0 = R2 - R1
  RSB     R0, R1, #256            ; R0 = 256 - R1
  RSB     R0, R2, R3,LSL#1        ; R0 = (R3 &lt;&lt; 1) - R2</pre>
<p style="padding:0px;margin:10px auto;text-indent:0px;">反向减法可以在有符号或无符号数上进行。</p>
<p style="padding:0px;margin:10px auto;text-indent:0px;">　</p>
<p style="padding:0px;margin:10px auto;text-indent:0px;">
</p><h2 style="padding:0px;font-size:21px;font-weight:bold;line-height:1.5;margin:10px 0px;">RSC : 带借位的反向减法</h2>
<p style="padding:0px;margin:10px auto;text-indent:0px;">(<span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">R</span>everse <span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">S</span>ubtraction with <span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">C</span>arry)</p>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">RSC{条件}{S}  &lt;dest&gt;, &lt;op 1&gt;, &lt;op 2&gt;

                dest = op_2 - op_1 - !carry</pre>
<p style="padding:0px;margin:10px auto;text-indent:0px;">同于 <code style="margin:0px;padding:0px;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:新宋体;">SBC</span></code>，但倒换了两个操作数的前后位置。</p>
<p style="padding:0px;margin:10px auto;text-indent:0px;">　</p>
<p style="padding:0px;margin:10px auto;text-indent:0px;">
</p><h2 style="padding:0px;font-size:21px;font-weight:bold;line-height:1.5;margin:10px 0px;">SBC : 带借位的减法</h2>
<p style="padding:0px;margin:10px auto;text-indent:0px;">(<span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">S</span>u<span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">b</span>traction with <span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">C</span>arry)</p>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">SBC{条件}{S}  &lt;dest&gt;, &lt;op 1&gt;, &lt;op 2&gt;

                dest = op_1 - op_2 - !carry</pre>
<p style="padding:0px;margin:10px auto;text-indent:0px;"><code style="margin:0px;padding:0px;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:新宋体;">SBC</span></code> 做两个操作数的减法，把结果放置到目的寄存器中。它使用进位标志来表示借位，这样就可以做大于 32 位的减法。<code style="margin:0px;padding:0px;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:新宋体;">SUB</span></code> 和 <code style="margin:0px;padding:0px;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:新宋体;">SBC</span></code> 生成进位标志的方式不同于常规，如果需要借位则<strong style="margin:0px;padding:0px;">清除</strong>进位标志。所以，指令要对进位标志进行一个<strong style="margin:0px;padding:0px;">非</strong>操作 - 在指令执行期间自动的反转此位。</p>
<p style="padding:0px;margin:10px auto;text-indent:0px;">　</p>
<p style="padding:0px;margin:10px auto;text-indent:0px;">
</p><h2 style="padding:0px;font-size:21px;font-weight:bold;line-height:1.5;margin:10px 0px;">SUB : 减法</h2>
<p style="padding:0px;margin:10px auto;text-indent:0px;">(<span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">Sub</span>traction)</p>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">SUB{条件}{S}  &lt;dest&gt;, &lt;op 1&gt;, &lt;op 2&gt;

                dest = op_1 - op_2</pre>
<p style="padding:0px;margin:10px auto;text-indent:0px;"><code style="margin:0px;padding:0px;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:新宋体;">SUB</span></code> 用操作数 <strong style="margin:0px;padding:0px;">one </strong>减去操作数<strong style="margin:0px;padding:0px;"> two</strong>，把结果放置到目的寄存器中。操作数 1 是一个寄存器，操作数 2 可以是一个寄存器，被移位的寄存器，或一个立即值:</p>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">SUB     R0, R1, R2              ; R0 = R1 - R2
  SUB     R0, R1, #256            ; R0 = R1 - 256
  SUB     R0, R2, R3,LSL#1        ; R0 = R2 - (R3 &lt;&lt; 1)</pre>
<p style="padding:0px;margin:10px auto;text-indent:0px;">减法可以在有符号和无符号数上进行。</p>
<h1 align="center" style="padding:0px;font-size:28px;font-weight:bold;line-height:1.5;margin:10px 0px;"><span style="margin:0px;padding:0px;line-height:1.5;color:#202020;">移位指令</span></h1>
<p style="padding:0px;margin:10px auto;text-indent:0px;">        ARM 处理器组建了可以与数据处理指令(ADC、ADD、AND、BIC、CMN、CMP、EOR、MOV、MVN、ORR、RSB、SBC、SUB、TEQ、TST)一起使用的桶式移位器(barrel shifter)。你还可以使用桶式移位器影响在 LDR/STR 操作中的变址值。</p>
<p style="padding:0px;margin:10px auto;text-indent:0px;">译注：移位操作在 ARM 指令集中不作为单独的指令使用，它是指令格式中是一个字段，在汇编语言中表示为指令中的选项。如果数据处理指令的第二个操作数或者单一数据传送指令中的变址是寄存器，则可以对它进行各种移位操作。如果数据处理指令的第二个操作数是立即值，在指令中用 8 位立即值和 4 位循环移位来表示它，所以对大于 255 的立即值，汇编器尝试通过在指令中设置循环移位数量来表示它，如果不能表示则生成一个错误。在逻辑类指令中，逻辑运算指令由指令中 S 位的设置或清除来确定是否影响进位标志，而比较指令的 S 位总是设置的。在单一数据传送指令中指定移位的数量只能用立即值而不能用寄存器。</p>
<p style="padding:0px;margin:10px auto;text-indent:0px;">下面是给不同的移位类型的六个助记符:</p>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">LSL  逻辑左移
  ASL  算术左移
  LSR  逻辑右移
  ASR  算术右移
  ROR  循环右移
  RRX  带扩展的循环右移</pre>
<p style="padding:0px;margin:10px auto;text-indent:0px;"><code style="margin:0px;padding:0px;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:新宋体;">ASL</span></code> 和 <code style="margin:0px;padding:0px;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:新宋体;">LSL</span></code> 是等同的，可以自由互换。</p>
<p style="padding:0px;margin:10px auto;text-indent:0px;">你可以用一个立即值(从 0 到 31)指定移位数量，或用包含在 0 和 31 之间的一个值的寄存器指定移位数量。</p>
<p style="padding:0px;margin:10px auto;text-indent:0px;"> </p>
<p style="padding:0px;margin:10px auto;text-indent:0px;">
</p><h2 style="padding:0px;font-size:21px;font-weight:bold;line-height:1.5;margin:10px 0px;">逻辑或算术左移</h2>
<p style="padding:0px;margin:10px auto;text-indent:0px;">(<span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">L</span>ogical or <span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">A</span>rithmetic <span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">S</span>hift <span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">L</span>eft)</p>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">Rx, LSL #n    or
  Rx, ASL #n    or
  Rx, LSL Rn    or
  Rx, ASL Rn</pre>
<p style="padding:0px;margin:10px auto;text-indent:0px;">接受 Rx 的内容并按用‘n’或在寄存器 Rn 中指定的数量向高有效位方向移位。最低有效位用零来填充。除了概念上的第 33 位(就是被移出的最小的那位)之外丢弃移出最左端的高位，如果逻辑类指令中 S 位被设置了，则此位将成为从桶式移位器退出时进位标志的值。</p>
<p style="padding:0px;margin:10px auto;text-indent:0px;">考虑下列:</p>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">MOV    R1, #12
  MOV    R0, R1, LSL#2</pre>
<p style="padding:0px;margin:10px auto;text-indent:0px;">在退出时，R0 是 48。 这些指令形成的总和是 <code style="margin:0px;padding:0px;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:新宋体;">R0 = #12, LSL#2</span></code> 等同于 BASIC 的 <code style="margin:0px;padding:0px;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:新宋体;">R0 = 12 &lt;&lt; 2</span></code></p>
<p style="padding:0px;margin:10px auto;text-indent:0px;"> </p>
<p style="padding:0px;margin:10px auto;text-indent:0px;">
</p><h2 style="padding:0px;font-size:21px;font-weight:bold;line-height:1.5;margin:10px 0px;">逻辑右移</h2>
<p style="padding:0px;margin:10px auto;text-indent:0px;">(<span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">L</span>ogical <span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">S</span>hift <span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">R</span>ight)</p>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">Rx, LSR #n    or
  Rx, LSR Rn</pre>
<p style="padding:0px;margin:10px auto;text-indent:0px;">它在概念上与左移相对。把所有位向更低有效位方向移动。如果逻辑类指令中 S 位被设置了，则把最后被移出最右端的那位放置到进位标志中。它同于 BASIC 的 <code style="margin:0px;padding:0px;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:新宋体;">register = value &gt;&gt;&gt; shift</span></code>。</p>
<p style="padding:0px;margin:10px auto;text-indent:0px;"> </p>
<p style="padding:0px;margin:10px auto;text-indent:0px;">
</p><h2 style="padding:0px;font-size:21px;font-weight:bold;line-height:1.5;margin:10px 0px;">算术右移</h2>
<p style="padding:0px;margin:10px auto;text-indent:0px;">(<span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">A</span>rithmetic <span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">S</span>hift <span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">R</span>ight)</p>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">Rx, ASR #n    or
  Rx, ASR Rn</pre>
<p style="padding:0px;margin:10px auto;text-indent:0px;">类似于 LSR，但使用要被移位的寄存器(Rx)的第 31 位的值来填充高位，用来保护补码表示中的符号。如果逻辑类指令中 S 位被设置了，则把最后被移出最右端的那位放置到进位标志中。它同于 BASIC 的 <code style="margin:0px;padding:0px;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:新宋体;">register = value &gt;&gt; shift</span></code>。</p>
<p style="padding:0px;margin:10px auto;text-indent:0px;"> </p>
<p style="padding:0px;margin:10px auto;text-indent:0px;">
</p><h2 style="padding:0px;font-size:21px;font-weight:bold;line-height:1.5;margin:10px 0px;">循环右移</h2>
<p style="padding:0px;margin:10px auto;text-indent:0px;">(<span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">Ro</span>tate <span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">R</span>ight)</p>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">Rx, ROR #n    or
  Rx, ROR Rn</pre>
<p style="padding:0px;margin:10px auto;text-indent:0px;">循环右移类似于逻辑右移，但是把从右侧移出去的位放置到左侧，如果逻辑类指令中 S 位被设置了，则同时放置到进位标志中，这就是位的‘循环’。一个移位量为 32 的操作将导致输出与输入完全一致，因为所有位都被移位了 32 个位置，又回到了开始时的位置!</p>
<p style="padding:0px;margin:10px auto;text-indent:0px;"> </p>
<p style="padding:0px;margin:10px auto;text-indent:0px;">
</p><h2 style="padding:0px;font-size:21px;font-weight:bold;line-height:1.5;margin:10px 0px;">带扩展的循环右移</h2>
<p style="padding:0px;margin:10px auto;text-indent:0px;">(<span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">R</span>otate <span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">R</span>ight with e<span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">x</span>tend)</p>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">Rx, RRX</pre>
<p style="padding:0px;margin:10px auto;text-indent:0px;">这是一个 ROR#0 操作，它向右移动一个位置 - 不同之处是，它使用处理器的进位标志来提供一个要被移位的 33 位的数量。</p>
<p style="padding:0px;margin:10px auto;text-indent:0px;">
</p><table border="0" style="word-break:break-word;font-size:inherit;font-style:inherit;font-variant:inherit;padding:0px;margin:0px;font-weight:inherit;border-spacing:0px;border-collapse:collapse;border:1px solid silver;display:block;overflow-x:scroll;" width="100%"><tbody style="margin:0px;padding:0px;"><tr style="margin:0px;padding:0px;"><td style="margin:0px;border:1px solid silver;border-collapse:collapse;padding:3px;white-space:nowrap;">
            <h1 align="center" style="padding:0px;font-size:28px;font-weight:bold;line-height:1.5;margin:10px 0px;"><span style="margin:0px;padding:0px;line-height:1.5;color:#202020;">乘法指令</span></h1>
            </td>
            <td align="center" style="margin:0px;border:1px solid silver;border-collapse:collapse;padding:3px;white-space:nowrap;" width="100"> </td>
        </tr></tbody></table></a><p style="padding:0px;margin:10px auto;text-indent:0px;"><a href="http://mk@msitstore:c:%20docume%7E1%20admini%7E1%20locals%7E1%20temp%20rar%24di00.188%20arm.chm/Html/arm/ARMinstrs.html#Multiplication" style="margin:0px;padding:0px;color:rgb(0, 0, 0);text-decoration:underline;">指令格式</a></p>
<p style="padding:0px;margin:10px auto;text-indent:0px;">这两个指令与普通<a href="http://mk@msitstore:c:%20docume%7E1%20admini%7E1%20locals%7E1%20temp%20rar%24di00.188%20arm.chm/Html/arm/mov.html" style="margin:0px;padding:0px;color:rgb(0, 0, 0);text-decoration:underline;">算术</a>指令在对操作数的限制上有所不同:</p>
<ol style="margin:0px;padding:0px;padding-left:40px;"><li style="margin:0px;padding:0px;list-style:none;margin-bottom:1em;list-style-type:decimal;">给出的所有操作数、和目的寄存器必须为简单的寄存器。</li>
    <li style="margin:0px;padding:0px;list-style:none;margin-bottom:1em;list-style-type:decimal;">你不能对操作数 2 使用立即值或被移位的寄存器。</li>
    <li style="margin:0px;padding:0px;list-style:none;margin-bottom:1em;list-style-type:decimal;">目的寄存器和操作数 1 必须是不同的寄存器。</li>
    <li style="margin:0px;padding:0px;list-style:none;margin-bottom:1em;list-style-type:decimal;">最后，你不能指定 R15 为目的寄存器。</li>
</ol><a name="mla" style="margin:0px;padding:0px;">
<h2 style="padding:0px;font-size:21px;font-weight:bold;line-height:1.5;margin:10px 0px;">MLA : 带累加的乘法</h2>
<p style="padding:0px;margin:10px auto;text-indent:0px;">(<span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">M</span>ultip<span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">l</span>ication with <span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">A</span>ccumulate)</p>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">MLA{条件}{S}  &lt;dest&gt;, &lt;op 1&gt;, &lt;op 2&gt;, &lt;op 3&gt;

                dest = (op_1 * op_2) + op_3</pre>
<p style="padding:0px;margin:10px auto;text-indent:0px;"><code style="margin:0px;padding:0px;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:新宋体;">MLA</span></code> 的行为同于 <code style="margin:0px;padding:0px;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:新宋体;">MUL</span></code>，但它把操作数 3 的值加到结果上。这在求总和时有用。</p>
<p style="padding:0px;margin:10px auto;text-indent:0px;">　</p>
<p style="padding:0px;margin:10px auto;text-indent:0px;">
</p><h2 style="padding:0px;font-size:21px;font-weight:bold;line-height:1.5;margin:10px 0px;">MUL : 乘法</h2>
<p style="padding:0px;margin:10px auto;text-indent:0px;">(<span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">Mul</span>tiplication)</p>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">MUL{条件}{S}  &lt;dest&gt;, &lt;op 1&gt;, &lt;op 2&gt;

                dest = op_1 * op_2</pre>
<p style="padding:0px;margin:10px auto;text-indent:0px;"><code style="margin:0px;padding:0px;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:新宋体;">MUL</span></code> 提供 32 位整数乘法。如果操作数是有符号的，可以假定结果也是有符号的。</p>
<p style="padding:0px;margin:10px auto;text-indent:0px;">
</p><table border="0" style="word-break:break-word;font-size:inherit;font-style:inherit;font-variant:inherit;padding:0px;margin:0px;font-weight:inherit;border-spacing:0px;border-collapse:collapse;border:1px solid silver;display:block;overflow-x:scroll;" width="100%"><tbody style="margin:0px;padding:0px;"><tr style="margin:0px;padding:0px;"><td style="margin:0px;border:1px solid silver;border-collapse:collapse;padding:3px;white-space:nowrap;">
            <h1 align="center" style="padding:0px;font-size:28px;font-weight:bold;line-height:1.5;margin:10px 0px;"><span style="margin:0px;padding:0px;line-height:1.5;color:#202020;">比较指令</span></h1>
            </td>
            <td align="center" style="margin:0px;border:1px solid silver;border-collapse:collapse;padding:3px;white-space:nowrap;" width="100"> </td>
        </tr></tbody></table></a><p style="padding:0px;margin:10px auto;text-indent:0px;"><a href="http://mk@msitstore:c:%20docume%7E1%20admini%7E1%20locals%7E1%20temp%20rar%24di00.188%20arm.chm/Html/arm/ARMinstrs.html#Data" style="margin:0px;padding:0px;color:rgb(0, 0, 0);text-decoration:underline;">指令格式</a></p>
<p style="padding:0px;margin:10px auto;text-indent:0px;">译注：CMP 和 CMP 是算术指令，TEQ 和 TST 是逻辑指令。把它们归入一类的原因是它们的 S 位总是设置的，就是说，它们总是影响标志位。</p>
<p style="padding:0px;margin:10px auto;text-indent:0px;">
</p><h2 style="padding:0px;font-size:21px;font-weight:bold;line-height:1.5;margin:10px 0px;">CMN : 比较取负的值</h2>
<p style="padding:0px;margin:10px auto;text-indent:0px;">(<span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">C</span>o<span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">m</span>pare <span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">N</span>egative)</p>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">CMN{条件}{P}  &lt;op 1&gt;, &lt;op 2&gt;

                status = op_1 - (- op_2)</pre>
<p style="padding:0px;margin:10px auto;text-indent:0px;"><code style="margin:0px;padding:0px;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:新宋体;">CMN</span></code> 同于 <code style="margin:0px;padding:0px;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:新宋体;">CMP</span></code>，但它允许你与小负值(操作数 2 的取负的值)进行比较，比如难于用其他方法实现的用于结束列表的 -1。这样与 -1 比较将使用:</p>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">CMN     R0, #1                  ; 把 R0 与 -1 进行比较</pre>
<p style="padding:0px;margin:10px auto;text-indent:0px;">详情参照 <code style="margin:0px;padding:0px;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:新宋体;">CMP</span></code> 指令。</p>
<p style="padding:0px;margin:10px auto;text-indent:0px;">　</p>
<p style="padding:0px;margin:10px auto;text-indent:0px;">
</p><h2 style="padding:0px;font-size:21px;font-weight:bold;line-height:1.5;margin:10px 0px;">CMP : 比较</h2>
<p style="padding:0px;margin:10px auto;text-indent:0px;">(<span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">C</span>o<span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">mp</span>are)</p>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">CMP{条件}{P}  &lt;op 1&gt;, &lt;op 2&gt;

                status = op_1 - op_2</pre>
<p style="padding:0px;margin:10px auto;text-indent:0px;"><code style="margin:0px;padding:0px;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:新宋体;">CMP</span></code> 允许把一个寄存器的内容如另一个寄存器的内容或立即值进行比较，更改状态标志来允许进行条件执行。它进行一次减法，但不存储结果，而是正确的更改标志。标志表示的是操作数 1 比操作数 2 如何(大小等)。如果操作数 1 大于操作操作数 2，则此后的有 GT 后缀的指令将可以执行。<br style="margin:0px;padding:0px;"/>
明显的，你不需要显式的指定 <code style="margin:0px;padding:0px;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:新宋体;">S</span></code> 后缀来更改状态标志... 如果你指定了它则被忽略。</p>
<p style="padding:0px;margin:10px auto;text-indent:0px;">　</p>
<p style="padding:0px;margin:10px auto;text-indent:0px;">
</p><h2 style="padding:0px;font-size:21px;font-weight:bold;line-height:1.5;margin:10px 0px;">TEQ : 测试等价</h2>
<p style="padding:0px;margin:10px auto;text-indent:0px;">(<span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">T</span>est <span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">Eq</span>uivalence)</p>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">TEQ{条件}{P}  &lt;op 1&gt;, &lt;op 2&gt;

                Status = op_1 EOR op_2</pre>
<p style="padding:0px;margin:10px auto;text-indent:0px;"><code style="margin:0px;padding:0px;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:新宋体;">TEQ</span></code> 类似于 <code style="margin:0px;padding:0px;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:新宋体;">TST</span></code>。区别是这里的概念上的计算是 EOR 而不是 AND。这提供了一种查看两个操作数是否相同而又不影响进位标志(不象 <code style="margin:0px;padding:0px;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:新宋体;">CMP</span></code>那样)的方法。加上 <code style="margin:0px;padding:0px;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:新宋体;">P</span></code> 后缀的 <code style="margin:0px;padding:0px;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:新宋体;">TEQ</span></code> 还可用于改变 R15 中的标志(在 26-bit 模式中)。详情请参照 <a href="http://mk@msitstore:c:%20docume%7E1%20admini%7E1%20locals%7E1%20temp%20rar%24di00.188%20arm.chm/Html/arm/psr.html" style="margin:0px;padding:0px;color:rgb(0, 0, 0);text-decoration:underline;">psr.html</a>，在 32-bit 模式下如何做请参见<a href="http://mk@msitstore:c:%20docume%7E1%20admini%7E1%20locals%7E1%20temp%20rar%24di00.188%20arm.chm/Html/arm/psr.html#32bit" style="margin:0px;padding:0px;color:rgb(0, 0, 0);text-decoration:underline;">这里</a>。</p>
<p style="padding:0px;margin:10px auto;text-indent:0px;">　</p>
<p style="padding:0px;margin:10px auto;text-indent:0px;">
</p><h2 style="padding:0px;font-size:21px;font-weight:bold;line-height:1.5;margin:10px 0px;">TST : 测试位</h2>
<p style="padding:0px;margin:10px auto;text-indent:0px;">(<span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">T</span>e<span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">st</span> bits)</p>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">TST{条件}{P}  &lt;op 1&gt;, &lt;op 2&gt;

                Status = op_1 AND op_2</pre>
<p style="padding:0px;margin:10px auto;text-indent:0px;"><code style="margin:0px;padding:0px;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:新宋体;">TST</span></code> 类似于 <code style="margin:0px;padding:0px;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:新宋体;">CMP</span></code>，不产生放置到目的寄存器中的结果。而是在给出的两个操作数上进行操作并把结果反映到状态标志上。使用 <code style="margin:0px;padding:0px;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:新宋体;">TST</span></code> 来检查是否设置了特定的位。操作数 1 是要测试的数据字而操作数 2 是一个位掩码。经过测试后，如果匹配则设置 Zero 标志，否则清除它。象 <span style="margin:0px;padding:0px;line-height:1.5;font-family:新宋体;"><code style="margin:0px;padding:0px;">CMP</code><code style="margin:0px;padding:0px;"> </code></span>那样，你不需要指定 <code style="margin:0px;padding:0px;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:新宋体;">S</span></code> 后缀。</p>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">TST     R0, #%1                 ; 测试在 R0 中是否设置了位 0。</pre>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;"> </pre>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;"><h1 align="center" style="padding:0px;font-size:28px;font-weight:bold;line-height:1.5;margin:10px 0px;"><span style="margin:0px;padding:0px;line-height:1.5;color:#202020;">分支指令</span></h1></pre>
<h2 style="padding:0px;font-size:21px;font-weight:bold;line-height:1.5;margin:10px 0px;">B : 分支</h2>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">(<span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">B</span>ranch)</pre>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">B{条件}  &lt;地址&gt;</pre>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;"><code style="margin:0px;padding:0px;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:新宋体;">B</span></code> 是最简单的分支。一旦遇到一个 <code style="margin:0px;padding:0px;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:新宋体;">B</span></code> 指令，ARM 处理器将立即跳转到给定的地址，从那里继续执行。</pre>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">注意存储在分支指令中的实际的值是相对当前的 R15 的值的一个偏移量；而不是一个绝对地址。</pre>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">它的值由汇编器来计算，它是 24 位有符号数，左移两位后有符号扩展为 32 位，表示的有效偏移为 26 位(+/- 32 M)。</pre>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">在其他处理器上，你可能经常见到这样的指令:</pre>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">OPT 1
  LDA &amp;70
  CMP #0
  BEQ Zero
  STA &amp;72
 .Zero RTS</pre>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">(取自 Acorn Electron User Guide issue 1 page 213)</pre>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">在 ARM 处理器上，它们将变成下面这些东西:</pre>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">OPT     1
  ADR     R1, #&amp;70
  LDR     R0, [R1]
  CMP     #0
  BEQ     Zero
  STR     R0, [R1, #2]
 .Zero
  MOV     PC, R14</pre>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">这不是一个很好的例子，但你可以构想如何更好的去条件执行而不是分支。另一方面，如果你有大段的代码或者你的代码使用状态标志，那么你可以使用条件执行来实现各类分支: 这样一个单一的简单条件执行指令可以替代在其他处理器中存在的所有这些分支和跳转指令。</pre>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">OPT     1
  ADR     R1, #&amp;70
  LDR     R0, [R1]
  CMP     R0, #0
  STRNE   R0, [R1, #2]
  MOV     PC, R14</pre>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;"><h2 style="padding:0px;font-size:21px;font-weight:bold;line-height:1.5;margin:10px 0px;">BL : 带连接的分支</h2>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">(<span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">B</span>ranch with <span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">L</span>ink)</pre>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">BL{条件}  &lt;地址&gt;</pre>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;"><code style="margin:0px;padding:0px;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:新宋体;">BL</span></code> 是另一个分支指令。就在分支之前，在寄存器 14 中装载上 R15 的内容。你可以重新装载 R14 到 R15 中来返回到在这个分支之后的那个指令，</pre>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">它是子例程的一个基本但强力的实现。它的作用在屏幕装载器 2 (例子 4)中得以很好的展现...</pre>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">.load_new_format
      BL     switch_screen_mode
      BL     get_screen_info
      BL     load_palette

    .new_loop
      MOV    R1, R5
      BL     read_byte
      CMP    R0, #255
      BLEQ   read_loop
      STRB   R0, [R2, #1]!</pre>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">...在这里我们见到在装载器循环之前调用了三个子例程。接着，一旦满足了条件执行就在循环中调用了 <em style="margin:0px;padding:0px;">read_byte</em> 子例程。</pre>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;"><table border="0" style="word-break:break-word;font-size:inherit;font-style:inherit;font-variant:inherit;padding:0px;margin:0px;font-weight:inherit;border-spacing:0px;border-collapse:collapse;border:1px solid silver;display:block;overflow-x:scroll;" width="100%"><tbody style="margin:0px;padding:0px;"><tr style="margin:0px;padding:0px;"><td style="margin:0px;border:1px solid silver;border-collapse:collapse;padding:3px;white-space:nowrap;"><h1 align="center" style="padding:0px;font-size:28px;font-weight:bold;line-height:1.5;margin:10px 0px;"><span style="margin:0px;padding:0px;line-height:1.5;color:#202020;">条件执行</span></h1></td><td align="center" style="margin:0px;border:1px solid silver;border-collapse:collapse;padding:3px;white-space:nowrap;" width="100"> </td></tr></tbody></table><p style="padding:0px;margin:10px auto;text-indent:0px;">　</p><h2 style="padding:0px;font-size:21px;font-weight:bold;line-height:1.5;margin:10px 0px;"><p style="padding:0px;margin:10px auto;text-indent:0px;"> </p>ARM 处理器的一个非常特殊的特征是它的条件执行。我们指的不是基本的如果进位则分支，ARM 使这个逻辑阶段进一步深化为如果进位则 <code style="margin:0px;padding:0px;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:新宋体;">XXX</span></code>- 这里的 XXX 是任何东西。<p style="padding:0px;margin:10px auto;text-indent:0px;">为了举例，下面是 Intel 8086 处理器分支指令的一个列表:</p><pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">JA    Jump if Above
  JAE   Jump if Above or Equal
  JB    Jump if Below
  JBE   Jump if Below or Equal
  JC    Jump if Carry
  JCXZ  Jump if CX Zero (CX is a register that can be used for loop counts)
  JE    Jump if Equal
  JG    Jump if Greater than
  JGE   Jump if Greater than or Equal
  JL    Jump if Less than
  JLE   Jump if Less Than or Equal
  JMP   JuMP
  JNA   Jump if Not Above
  JNAE  Jump if Not Above or Equal
  JNB   Jump if Not Below
  JNBE  Jump if Not Below or Equal
  JNC   Jump if No Carry
  JNE   Jump if Not Equal
  JNG   Jump if Not Greater than
  JNGE  Jump if Not Greater than or Equal
  JNL   Jump if Not Less than
  JNLE  Jump if Not Less than or Equal
  JNO   Jump if Not Overflow
  JNP   Jump if Not Parity
  JNS   Jump if Not Sign
  JNZ   Jump if Not Zero
  JO    Jump if Overflow
  JP    Jump if Parity
  JPE   Jump if Parity Even
  JPO   Jump if Parity Odd
  JS    Jump if Sign
  JZ    Jump if Zero

80386 添加了:
  JECXZ Jump if ECX Zero</pre>
作为对比，ARM 处理器只提供了:
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">B     分支
  BL    带连接的分支</pre>
但 ARM 提供了条件执行，你可以不受这个表面上不灵活的方式的限制:
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">BEQ   Branch if EQual
  BNE   Branch if Not Equal
  BVS   Branch if oVerflow Set
  BVC   Branch if oVerflow Clear
  BHI   Branch if HIgher
  BLS   Branch if Lower or the Same
  BPL   Branch if PLus
  BMI   Branch if MInus
  BCS   Branch if Carry Set
  BCC   Branch if Carry Clear
  BGE   Branch if Greater than or Equal
  BGT   Branch if Greater Than
  BLE   Branch if Less than or Equal
  BLT   Branch if Less Than

  BLEQ  Branch with Link if EQual
  ....
  BLLT  Branch with Link if Less Than</pre>
还有两个代码，
<ul style="margin:0px;padding:0px;word-break:break-all;margin-left:30px;padding-left:0px;"><li style="margin:0px;padding:0px;list-style:none;margin-bottom:1em;list-style-type:disc;"><code style="margin:0px;padding:0px;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:新宋体;">AL</span></code> - ALways，缺省条件所以不须指定</li>
    <li style="margin:0px;padding:0px;list-style:none;margin-bottom:1em;list-style-type:disc;"><code style="margin:0px;padding:0px;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:新宋体;">NV</span></code> - NeVer，不是非常有用。你无论如何不要使用这个代码...</li>
</ul>
当你发现所有 Bxx 指令实际上是同一个指令的时候，紧要关头就到了。
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">接着你会想，如果你可以在一个分支指令上加上所有这些条件，那么对一个寄存器装载指令能否加上它们? 答案是可以。 <p style="padding:0px;margin:10px auto;text-indent:0px;">下面是可获得的条件代码的列表:</p></pre><dl style="margin:0px;padding:0px;"><dt style="margin:0px;padding:0px;">EQ : 等于 </dt><dd style="margin:0px;padding:0px;">如果一次比较之后设置了 Z 标志。 </dd><dt style="margin:0px;padding:0px;">　 </dt><dt style="margin:0px;padding:0px;">NE : 不等于 </dt><dd style="margin:0px;padding:0px;">如果一次比较之后清除了 Z 标志。 </dd><dt style="margin:0px;padding:0px;">　 </dt><dt style="margin:0px;padding:0px;">VS : 溢出设置 </dt><dd style="margin:0px;padding:0px;">如果在一次算术操作之后设置了 V 标志，计算的结果不适合放入一个 32bit 目标寄存器中。 </dd><dt style="margin:0px;padding:0px;">　 </dt><dt style="margin:0px;padding:0px;">VC : 溢出清除 </dt><dd style="margin:0px;padding:0px;">如果清除了 V 标志，与 VS 相反。 </dd><dt style="margin:0px;padding:0px;">　 </dt><dt style="margin:0px;padding:0px;">HI : 高于(无符号) </dt><dd style="margin:0px;padding:0px;">如果一次比较之后设置了 C 标志<strong style="margin:0px;padding:0px;">并</strong>清除了 Z 标志。 </dd><dt style="margin:0px;padding:0px;">　 </dt><dt style="margin:0px;padding:0px;">LS : 低于或同于(无符号) </dt><dd style="margin:0px;padding:0px;">如果一次比较操作之后清除了 C 标志<strong style="margin:0px;padding:0px;">或</strong>设置了 Z 标志。 </dd><dt style="margin:0px;padding:0px;">　 </dt><dt style="margin:0px;padding:0px;">PL : 正号 </dt><dd style="margin:0px;padding:0px;">如果一次算术操作之后清除了 N。出于定义‘正号’的目的，零是正数的原因是它不是负数... </dd><dt style="margin:0px;padding:0px;">　 </dt><dt style="margin:0px;padding:0px;">MI : 负号 </dt><dd style="margin:0px;padding:0px;">如果一次算术操作之后设置了 N 标志。 </dd><dt style="margin:0px;padding:0px;">　 </dt><dt style="margin:0px;padding:0px;">CS : 进位设置 </dt><dd style="margin:0px;padding:0px;">如果一次算术操作或移位操作之后设置了 C 标志，操作的结果不能表示为 32bit。你可以把 C 标志当作结果的第 33 位。 </dd><dt style="margin:0px;padding:0px;">　 </dt><dt style="margin:0px;padding:0px;">CC : 进位清除 </dt><dd style="margin:0px;padding:0px;">与 CS 相反。 </dd><dt style="margin:0px;padding:0px;">　 </dt><dt style="margin:0px;padding:0px;">GE : 大于或等于(有符号) </dt><dd style="margin:0px;padding:0px;">如果一次比较之后...<br style="margin:0px;padding:0px;"/>设置了 N 标志<strong style="margin:0px;padding:0px;">并</strong>设置了 V 标志<br style="margin:0px;padding:0px;"/>或者...<br style="margin:0px;padding:0px;"/>清除了 N 标志<strong style="margin:0px;padding:0px;">并</strong>清除了 V 标志。 </dd><dt style="margin:0px;padding:0px;">　 </dt><dt style="margin:0px;padding:0px;">GT : 大于(有符号) </dt><dd style="margin:0px;padding:0px;">如果一次比较之后...<br style="margin:0px;padding:0px;"/>设置了 N 标志<strong style="margin:0px;padding:0px;">并</strong>设置了 V 标志<br style="margin:0px;padding:0px;"/>或者...<br style="margin:0px;padding:0px;"/>清除了 N 标志<strong style="margin:0px;padding:0px;">并</strong>清除了 V 标志<br style="margin:0px;padding:0px;"/><strong style="margin:0px;padding:0px;">并且</strong>...<br style="margin:0px;padding:0px;"/>清除了 Z 标志。 </dd><dt style="margin:0px;padding:0px;">　 </dt><dt style="margin:0px;padding:0px;">LE : 小于或等于(有符号) </dt><dd style="margin:0px;padding:0px;">如果一次比较之后...<br style="margin:0px;padding:0px;"/>设置了 N 标志<strong style="margin:0px;padding:0px;">并</strong>清除了 V 标志<br style="margin:0px;padding:0px;"/>或者...<br style="margin:0px;padding:0px;"/>清除了 N 标志<strong style="margin:0px;padding:0px;">并</strong>设置了 V 标志<br style="margin:0px;padding:0px;"/><strong style="margin:0px;padding:0px;">并且</strong>...<br style="margin:0px;padding:0px;"/>设置了 Z 标志。 </dd><dt style="margin:0px;padding:0px;">　 </dt><dt style="margin:0px;padding:0px;">LT : 小于(有符号) </dt><dd style="margin:0px;padding:0px;">如果一次比较之后...<br style="margin:0px;padding:0px;"/>设置了 N 标志<strong style="margin:0px;padding:0px;">并</strong>清除了 V 标志。<br style="margin:0px;padding:0px;"/>或者...<br style="margin:0px;padding:0px;"/>清除了 N 标志<strong style="margin:0px;padding:0px;">并</strong>设置了 V 标志。 </dd><dt style="margin:0px;padding:0px;">　 </dt><dt style="margin:0px;padding:0px;">AL : 总是 </dt><dd style="margin:0px;padding:0px;">缺省条件，所以不用明显声明。 </dd><dt style="margin:0px;padding:0px;">　 </dt><dt style="margin:0px;padding:0px;">NV : 从不 </dt><dd style="margin:0px;padding:0px;">不是特别有用，它表示应当永远不执行这个指令。是穷人的 NOP。<br style="margin:0px;padding:0px;"/>包含 NV 是为了完整性(与 AL 相对)，你不应该在你的代码中使用它。 </dd></dl>有一个在最后的条件代码 <code style="margin:0px;padding:0px;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:新宋体;">S，</span></code>它以相反的方式工作。当用于一个指令的时候，导致更改状态标志。这不是自动发生的 - 除非这些指令的目的是设置状态。例如: <pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">ADD     R0, R0, R1

  ADDS    R0, R0, R1

  ADDEQS  R0, R0, R1</pre>
第一个例子是一个基本的加法(把 R1 的值增加到 R0)，它不影响状态寄存器。
<p style="padding:0px;margin:10px auto;text-indent:0px;">第二个例子是同一个加法，只不过它导致更改状态寄存器。</p>
<p style="padding:0px;margin:10px auto;text-indent:0px;">最后一个例子是同一个加法，更改状态寄存器。不同在于它是一个有条件的指令。只有前一个操作的结果是 EQ (如果设置了 Z 标志)的时候它才执行。</p>
<p style="padding:0px;margin:10px auto;text-indent:0px;">下面是条件执行的一个工作中的例子。你把寄存器 0 与存储在寄存器 10 中内容相比较。</p>
<p style="padding:0px;margin:10px auto;text-indent:0px;">如果不等于 R10，则调用一个软件中断，增加它并分支回来再次做这些。否则清除 R10 并返回到调用它的那部分代码(它的地址存储在 R14)。</p>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">\ 条件执行的一个例子

  .loop                           ; 标记循环开始位置
  CMP     R0, R10                 ; 把 R0 与 R10 相比较
  SWINE   &amp;40017                  ; 不等于: 调用 SWI &amp;40017
  ADDNE   R0, R0, #1              ;         向 R0 加 1
  BNE     loop                    ;         分支到 'loop'
  MOV     R10, #0                 ; 等于  : 设置 R10 为零
  LDMFD   R13!, {R0-R12,PC}       ;         返回到调用者</pre>
注解:
<ul style="margin:0px;padding:0px;word-break:break-all;margin-left:30px;padding-left:0px;"><li style="margin:0px;padding:0px;list-style:none;margin-bottom:1em;list-style-type:disc;">SWI 编号就象我写的这样。在 RISC OS 下，它是给 <em style="margin:0px;padding:0px;">Econet_DoImmediate</em> 的编号。不要字面的接受它，这只是一个例子!</li>
    <li style="margin:0px;padding:0px;list-style:none;margin-bottom:1em;list-style-type:disc;">你可能以前没见过 <code style="margin:0px;padding:0px;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:新宋体;">LDMFD，</span></code>它从栈中装载多个寄存器。在这个例子中，我们从一个完全正式的栈中装载 R0 至 R12 和 R14。关于寄存器装载和存储的更多信息请参阅 <a href="http://mk@msitstore:c:%20docume%7E1%20admini%7E1%20locals%7E1%20temp%20rar%24di00.188%20arm.chm/Html/arm/str.html" style="margin:0px;padding:0px;color:rgb(0, 0, 0);text-decoration:underline;">str.html</a>。</li>
    <li style="margin:0px;padding:0px;list-style:none;margin-bottom:1em;list-style-type:disc;">我说要装载 R14。那么为什么要把它放入 PC 中? 原因是此时 R14 存储的值包含返回地址。我们也可以采用:<br style="margin:0px;padding:0px;"/><span style="margin:0px;padding:0px;line-height:1.5;font-family:新宋体;"><code style="margin:0px;padding:0px;">LDMFD      R13!, {R0-R12,R14}<br style="margin:0px;padding:0px;"/>
    MOV        PC, R14</code><br style="margin:0px;padding:0px;"/></span>但是直接恢复到 PC 中可以省略这个 <code style="margin:0px;padding:0px;"><span style="margin:0px;padding:0px;line-height:1.5;font-family:新宋体;">MOV</span></code> 语句。</li>
    <li style="margin:0px;padding:0px;list-style:none;margin-bottom:1em;list-style-type:disc;">最后，这些寄存器很有可能被一个 SWI 调用所占用(依赖于在调用期间执行的代码)，所以你最好把你的重要的寄存器压入栈中，以后在恢复它们。</li>
</ul><table border="0" style="word-break:break-word;font-size:inherit;font-style:inherit;font-variant:inherit;padding:0px;margin:0px;font-weight:inherit;border-spacing:0px;border-collapse:collapse;border:1px solid silver;display:block;overflow-x:scroll;" width="100%"><tbody style="margin:0px;padding:0px;"><tr style="margin:0px;padding:0px;"><td style="margin:0px;border:1px solid silver;border-collapse:collapse;padding:3px;white-space:nowrap;">
            <h1 align="center" style="padding:0px;font-size:28px;font-weight:bold;line-height:1.5;margin:10px 0px;"><span style="margin:0px;padding:0px;line-height:1.5;color:#202020;">SWI 指令</span></h1>
            </td>
            <td align="center" style="margin:0px;border:1px solid silver;border-collapse:collapse;padding:3px;white-space:nowrap;" width="100"> </td>
        </tr></tbody></table><p style="padding:0px;margin:10px auto;text-indent:0px;"><span style="margin:0px;padding:0px;line-height:48px;font-size:27px;font-weight:bold;">SWI : 软件中断</span></p>
<p style="padding:0px;margin:10px auto;text-indent:0px;">(<span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">S</span>oft<span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">w</span>are <span style="margin:0px;padding:0px;line-height:1.5;color:#0000ff;">I</span>nterrupt)</p>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">SWI{条件}  &lt;24 位编号&gt;</pre>
<a href="http://mk@msitstore:c:%20docume%7E1%20admini%7E1%20locals%7E1%20temp%20rar%24di00.188%20arm.chm/Html/arm/ARMinstrs.html#Software" style="margin:0px;padding:0px;color:rgb(0, 0, 0);text-decoration:underline;">指令格式</a>
<p style="padding:0px;margin:10px auto;text-indent:0px;">这是一个简单的设施，但可能是最常用的。多数操作系统设施是用 SWI 提供的。没有 SWI 的 RISC OS 是不可想象的。</p>
<p style="padding:0px;margin:10px auto;text-indent:0px;">Nava Whiteford 解释了 SWI 是如何工作的(最初在 Frobnicate issue 12?)...</p>
<p style="padding:0px;margin:10px auto;text-indent:0px;">　</p>
</h2><h2 style="padding:0px;font-size:21px;font-weight:bold;line-height:1.5;margin:10px 0px;">SWI 是什么?</h2>
SWI 表示 Software Interrupt。在 RISC OS  中使用 SWI 来访问操作系统例程或第三方生产的模块。许多应用使用模块来给其他应用提供低层外部访问。
<p style="padding:0px;margin:10px auto;text-indent:0px;">SWI 的例子有:</p>
<ul style="margin:0px;padding:0px;word-break:break-all;margin-left:30px;padding-left:0px;"><li style="margin:0px;padding:0px;list-style:none;margin-bottom:1em;list-style-type:disc;">文件器 SWI，它辅助读写磁盘、设置属性等。</li>
    <li style="margin:0px;padding:0px;list-style:none;margin-bottom:1em;list-style-type:disc;">打印机驱动器 SWI，用来辅助使用打印并行端口。</li>
    <li style="margin:0px;padding:0px;list-style:none;margin-bottom:1em;list-style-type:disc;">FreeNet/Acorn TCP/IP 协议栈 SWI，用 TCP/IP 协议在 Internet 上发送和接收数据。</li>
</ul><p style="padding:0px;margin:10px auto;text-indent:0px;">在以这种方式使用的时候，SWI 允许操作系统拥有一个模块结构，这意味着用来建立完整的操作系统的所需的代码可以被分割成许多小的部分(模块)和一个模块处理程序(handler)。</p>
<p style="padding:0px;margin:10px auto;text-indent:0px;">当 SWI 处理程序得到对特定的例程编号的一个请求的时候，它找到这个例程的位置并执行它，并传递(有关的)任何数据。</p>
<h2 style="padding:0px;font-size:21px;font-weight:bold;line-height:1.5;margin:10px 0px;">它是如何工作的?</h2>
首先查看一下如何使用它。一个 SWI 指令(汇编语言)看起来如下:
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">SWI &amp;02</pre>
或
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">SWI &quot;OS_Write0&quot;</pre>
这些指令实际上是相同的，将被汇编成相同的指令。唯一的不同是第二个指令使用一个字符串来表示 SWI 编号 &amp;02。
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">在使用采用了字符串编号的程序的时候，在执行之前首先查找这个字符串。 <p style="padding:0px;margin:10px auto;text-indent:0px;">在这里我们不想处理字符串，因为它不能给出它要进行什么的一个真实表示。它们通常用于增进一个程序的清晰程度，但不是实际执行的指令。</p><p style="padding:0px;margin:10px auto;text-indent:0px;">让我们再次看一下第一个指令:</p><pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">SWI &amp;02</pre>
这是什么意思? 字面的意思是进入 SWI 处理程序并传递值 &amp;02。在 RISC OS 中这意味着执行编号是 &amp;02 的例程。
<p style="padding:0px;margin:10px auto;text-indent:0px;">它是如何这么作的? 它如何传递 SWI 编号和进入 SWI 处理程序?</p>
<p style="padding:0px;margin:10px auto;text-indent:0px;">如果你查看内存的开始 32 字节(位于 0-&amp;1C)并反汇编它们(查开实际的 ARM 指令)你将见到如下:</p>
<p style="padding:0px;margin:10px auto;text-indent:0px;">　</p>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">地址       内容               反汇编
00000000 : 0..? : E5000030 : STR     R0,[R0,#-48]
00000004 : .ó?? : E59FF31C : LDR     PC,&amp;00000328
00000008 : .ó?? : E59FF31C : LDR     PC,&amp;0000032C
0000000C : .ó?? : E59FF31C : LDR     PC,&amp;00000330
00000010 : .ó?? : E59FF31C : LDR     PC,&amp;00000334
00000014 : .ó?? : E59FF31C : LDR     PC,&amp;00000338
00000018 : .ó?? : E59FF31C : LDR     PC,&amp;0000033C
0000001C :  2?? : E3A0A632 : MOV     R10,#&amp;3200000</pre>
让我们仔细看一下。
<p style="padding:0px;margin:10px auto;text-indent:0px;">除了第一个和最后一个指令之外(它们是特殊情况)你见到的都是把一个新值装载到 PC (程序计数器)的指令，它们告诉计算机到哪里去执行下一个指令。</p>
<p style="padding:0px;margin:10px auto;text-indent:0px;">还展示了这个值是从内存中的一个地址接受来的。(你可以在 !Zap 主菜单上使用“Read Memory”选项去自己查看一下。)</p>
<p style="padding:0px;margin:10px auto;text-indent:0px;">这看起来好象与 SWI 没多少关系，下面做进一步的说明。</p>
<p style="padding:0px;margin:10px auto;text-indent:0px;">一个 SWI 所做的一切就是把模式改变成超级用户并设置 PC 来执行在地址 &amp;08 处的下一个指令!</p>
<p style="padding:0px;margin:10px auto;text-indent:0px;">把处理器转换到超级用户模式会切换掉两个寄存器 r13 和 r14 并用 r13_svc 和 r14_svc 替换它们。</p>
<p style="padding:0px;margin:10px auto;text-indent:0px;">在进入超级用户模式的时候，还把 r14_svc 设置为在这个 SWI 指令之后的地址。</p>
<p style="padding:0px;margin:10px auto;text-indent:0px;">这个实际上就象一个连接到地址 &amp;08 的分支指令(BL &amp;08)，但带有用于一些数据(SWI 编号)的空间。</p>
<p style="padding:0px;margin:10px auto;text-indent:0px;">象我说过的那样，地址 &amp;08 包含跳转到另一个地址的一个指令，就是实际的 SWI 程序的地址!</p>
<p style="padding:0px;margin:10px auto;text-indent:0px;">此时你可能会想“稍等一会! 还有 SWI 编号呢?”。实际上处理器忽略这个值本身。SWI 处理程序使用传递来的 r14_svc 的值来获取它。</p>
<p style="padding:0px;margin:10px auto;text-indent:0px;">下面是完成它的步骤(在存储寄存器 r0-r12 之后):</p>
<ol style="margin:0px;padding:0px;padding-left:40px;"><li style="margin:0px;padding:0px;list-style:none;margin-bottom:1em;list-style-type:decimal;">它从 r14 中减去 4 来获得 SWI 指令的地址。</li>
    <li style="margin:0px;padding:0px;list-style:none;margin-bottom:1em;list-style-type:decimal;">把这个指令装载到一个寄存器。</li>
    <li style="margin:0px;padding:0px;list-style:none;margin-bottom:1em;list-style-type:decimal;">清除这个指令的高端 8 位，去掉了 OpCode 而只剩下的 SWI 编号。</li>
    <li style="margin:0px;padding:0px;list-style:none;margin-bottom:1em;list-style-type:decimal;">使用这个值来找到要被执行的代码的例程的地址(使用查找表等)。</li>
    <li style="margin:0px;padding:0px;list-style:none;margin-bottom:1em;list-style-type:decimal;">恢复寄存器 r0-r12。</li>
    <li style="margin:0px;padding:0px;list-style:none;margin-bottom:1em;list-style-type:decimal;">使处理器离开超级用户模式。</li>
    <li style="margin:0px;padding:0px;list-style:none;margin-bottom:1em;list-style-type:decimal;">跳转到这个例程的地址。</li>
</ol>
容易吧! ;)
<p style="padding:0px;margin:10px auto;text-indent:0px;">下面是一个例子，来自 ARM610 datasheet:</p>
<pre style="margin:0px;padding:0px;margin-top:0px;margin-bottom:0px;white-space:pre-wrap;word-wrap:break-word;">0x08 B Supervisor

EntryTable
 DCD ZeroRtn
 DCD ReadCRtn
 DCD WriteIRtn

 ...

Zero   EQU 0
ReadC  EQU 256
WriteI EQU 512
 
; SWI 包含需要的例程在位 8-23 中和数据(如果有的话)在位 0-7 中。
; 假定 R13_svc 指向了一个合适的栈

STMFD R13, {r0-r2 , R14}
 ; 保存工作寄存器和返回地址。
LDR R0,[R14,#-4]
 ; 得到 SWI 指令。
BIC R0,R0, #0xFF000000
 ; 清除高端的 8 位。
MOV R1, R0, LSR #8
 ; 得到例程偏移量。
ADR R2, EntryTable
 ; 得到入口表(EntryTable)的开始地址。
LDR R15,[R2,R1,LSL #2]
 ; 分支到正确的例程

WriteIRtn
 ; 写 R0 中的位 0 - 7 中的字符。

.............
 LDMFD R13, {r0-r2 , R15}^
 ; 恢复工作空间，并返回、恢复处理器模式和标志。</pre>
这就是 SWI 指令的基本处理步骤。</pre> </pre></pre></span></div></div></div></div></div></div></div></div></div></div></div></div><br/></div></span>
</div></body></html> 